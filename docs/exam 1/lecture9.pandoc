## AE 737: Mechanics of Damage Tolerance
Lecture 9 - Residual Strength

Dr. Nicholas Smith

Wichita State University, Department of Aerospace Engineering

15 February 2022


## schedule

- 15 Feb - Residual Strength
- 17 Feb - Residual Strength, HW4 Due, HW 3 Self-grade due
- 22 Feb - Multiple Site Damage, Mixed-Mode
- 24 Feb - Exam 1 Review


## outline
<!-- TOC START min:1 max:1 link:false update:true -->
- residual strength
- fedderson approach
- proof testing
- residual strength review

<!-- TOC END -->


# R-curve


## R-curve

-   For materials with some plasticity, the \\(K_R\\) Curve, or R Curve, is very important
-   Sometimes called a "resistance curve" it is generally dependent on
    -   Thickness
    -   Temperature
    -   Strain rate


## R-curve

-   When done correctly, \\(K_R\\) curves are not dependent on initial crack size or the specimen type used
-   ASTM E561 describes a general procedure


## \\(K_{c}\\)

-   While we can look up plane stress \\(K_c\\) for various materials, it is best if we have a \\(K_R\\) curve
-   We may not know if the table uses \\(K_c\\) using the tangent intersection method, or maximum stress intensity
-   Even if tangent intersection method is used, \\(K_c\\) will different somewhat based on initial crack length


## R-curve

-   There are two main methods for plotting the R-curve
-   Crack size is measured directly (possibly with a drawn-on scale and camera)
-   Effective crack size is calculated from the load-displacement data


## physical crack

-   When the physical crack size is measured, we need to calculate the effective crack length (and effective stress intensity factor) at each data point
-   The effective crack length calculated from the load-displacement data already has the plastic zone effect built in


## plane stress fracture toughness

-   For a plane stress (or any thickness that is not plane strain) we can find \\(K_c\\) two ways
-   One way is simply the maximum value of the \\(K_{R}\\) curve, but this does not account for unstable crack growth
-   The more reliable way is to use the tangent intersection method


## tangent intersection method

-   Construct curves for \\(K_{I}\\) based on our specimen geometry with constant applied load and varying crack length
-   Plot these curves on the same graph as \\(K_{R}\\)
-   NOTE: \\(K_{R}\\) curve should be plotted vs. \\(a_{eff}\\), not \\(\Delta a\\) or \\(\Delta a_{eff}\\)
-   \\(K_{c}\\) is the point at which one of the \\(K_{I}\\) curves is the tangent intersection with the \\(K_{R}\\) curve


## R-Curve examples

-   [example](https://colab.research.google.com/drive/1TlGuadrMRM5xSGic8soVFglPDyWuDaeP?usp=sharing)
-   Excel Solver



# residual strength


## residual strength

-   As the crack grows, the area of the sample decreases, increasing the net section stress
-   The residual strength, \\(\sigma_R\\) is given in terms of the gross area, so as the crack grows the residual strength due to yield decreases
-   We can relate the net-section stress to \\(\sigma_R\\) by

\\[\sigma_R = \sigma_{YS} \frac{A_{net}}{A_{gross}}\\]


## residual strength

![Effective yield strength plotted vs. crack length. As the crack gets longer, the actual cross-sectional area decreases so that the effective yield strength also goes down.](../images/residual-strength.PNG) <!-- .element width="60%" -->


## residual strength

-   For brittle fracture to occur, we need to satisfy the condition
		
\\[\sigma_R = \sigma_C = \frac{K_C}{\sqrt{\pi a}\beta}\\]


## residual strength

![Here the effective K_i is plotted vs. crack length and compared to the net section yield. The lower of the two values will cause failure.](../images/residual-tough.PNG) <!-- .element width="60%" -->


## residual strength

-   Within the same family of materials (i.e. Aluminum), there is generally a trade-off between yield stress and fracture toughness
-   As we increase the yield strength, we decrease the fracture toughness (and vice versa)
-   Consider a comparison of the following aluminum alloys
    1.  7178-T6, \\(K_C = 43 \text{ ksi} \sqrt{\text{in.}}\\), \\(\sigma_{YS} = 74\\) ksi
    2.  7075-T6, \\(K_C = 68 \text{ ksi} \sqrt{\text{in.}}\\), \\(\sigma_{YS} = 63\\) ksi
    3.  2024-T3, \\(K_C = 144 \text{ ksi} \sqrt{\text{in.}}\\), \\(\sigma_{YS} = 42\\) ksi


## residual strength

-   As an example let us consider an edge-cracked panel with W=6" and t=0.1"
-   The net section yield condition will be given by

\\[\sigma_C = \sigma_{YS} \frac{W-a}{W} = \sigma_{YS}\frac{6-a}{6}\\]

-   And the fracture condition by

\\[\sigma_C = \frac{K_C}{\sqrt{\pi a} \beta}\\]

With

\\[\small\{\beta = 1.12 - 0.231\left(\frac{a}{W}\right) + 10.55 \left(\frac{a}{W}\right)^2 - 21.72 \left(\frac{a}{W}\right)^3 + 30.39 \left(\frac{a}{W}\right)^4\}\\]


## 7178-T6

<div class="anything" id="7178">
<!--
{
  "initialize": "function(container) {
  function makeArr(startValue, stopValue, numVals) {
      var arr = [];
      var currValue = startValue;
      var step = (stopValue-startValue)/(numVals-1);
      for (var i = 1; i < numVals; i++) {
        arr.push(currValue + step*i);
      }
      return arr;
    }
  function toughness(k,x) {
    var y = [];
    for (var i = 0; i < x.length; i++) {
      y.push(k/(Math.PI*x[i]*6)**.5/(1.12-.231*x[i]+10.55*x[i]**2-21.72*x[i]**3+30.39*x[i]**4));
    }
    return y;
  }
  function netsection(s,x) {
    var y = [];
    for (var i = 0; i < x.length; i++){
      y.push(s*(1-x[i]));
    }
    return y;
  }
  var trace1 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: 'fracture'
  };
  trace1.y = toughness(43,trace1.x);
  var trace2 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: 'yield'
  };
  trace2.y = netsection(74,trace2.x);
  var data = [trace1, trace2];
  layout = {
    xaxis: {
      title: 'a/W'
    },
    yaxis: {
      title: 'residual strength',
      range: [0,80]
    }
  };
  Plotly.newPlot('7178', data, layout);
	}"
}
-->
:::

## 7075-T6

<div class="anything" id="7075">
<!--
{
  "initialize": "function(container) {
  function makeArr(startValue, stopValue, numVals) {
      var arr = [];
      var currValue = startValue;
      var step = (stopValue-startValue)/(numVals-1);
      for (var i = 1; i < numVals; i++) {
        arr.push(currValue + step*i);
      }
      return arr;
    }
  function toughness(k,x) {
    var y = [];
    for (var i = 0; i < x.length; i++) {
      y.push(k/(Math.PI*x[i]*6)**.5/(1.12-.231*x[i]+10.55*x[i]**2-21.72*x[i]**3+30.39*x[i]**4));
    }
    return y;
  }
  function netsection(s,x) {
    var y = [];
    for (var i = 0; i < x.length; i++){
      y.push(s*(1-x[i]));
    }
    return y;
  }
  var trace1 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: 'fracture'
  };
  trace1.y = toughness(68,trace1.x);
  var trace2 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: 'yield'
  };
  trace2.y = netsection(63,trace2.x);
  var data = [trace1, trace2];
  layout = {
    xaxis: {
      title: 'a/W'
    },
    yaxis: {
      title: 'residual strength',
      range: [0, 80]
    }
  };
  Plotly.newPlot('7075', data, layout);
	}"
}
-->
:::

## 2024-T3

<div class="anything" id="2024">
<!--
{
  "initialize": "function(container) {
  function makeArr(startValue, stopValue, numVals) {
      var arr = [];
      var currValue = startValue;
      var step = (stopValue-startValue)/(numVals-1);
      for (var i = 1; i < numVals; i++) {
        arr.push(currValue + step*i);
      }
      return arr;
    }
  function toughness(k,x) {
    var y = [];
    for (var i = 0; i < x.length; i++) {
      y.push(k/(Math.PI*x[i]*6)**.5/(1.12-.231*x[i]+10.55*x[i]**2-21.72*x[i]**3+30.39*x[i]**4));
    }
    return y;
  }
  function netsection(s,x) {
    var y = [];
    for (var i = 0; i < x.length; i++){
      y.push(s*(1-x[i]));
    }
    return y;
  }
  var trace1 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: 'fracture'
  };
  trace1.y = toughness(144,trace1.x);
  var trace2 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: 'yield'
  };
  trace2.y = netsection(42,trace2.x);
  var data = [trace1, trace2];
  layout = {
    xaxis: {
      title: 'a/W'
    },
    yaxis: {
      title: 'residual strength',
      range: [0, 80]
    }
  };
  Plotly.newPlot('2024', data, layout);
	}"
}
-->
:::

## comparison

<div class="anything" id="comparison">
<!--
{
  "initialize": "function(container) {
  function makeArr(startValue, stopValue, numVals) {
      var arr = [];
      var currValue = startValue;
      var step = (stopValue-startValue)/(numVals-1);
      for (var i = 1; i < numVals; i++) {
        arr.push(currValue + step*i);
      }
      return arr;
    }
  function toughness(k,x) {
    var y = [];
    for (var i = 0; i < x.length; i++) {
      y.push(k/(Math.PI*x[i]*6)**.5/(1.12-.231*x[i]+10.55*x[i]**2-21.72*x[i]**3+30.39*x[i]**4));
    }
    return y;
  }
  function netsection(s,x) {
    var y = [];
    for (var i = 0; i < x.length; i++){
      y.push(s*(1-x[i]));
    }
    return y;
  }
  function minval(k,s,x) {
    var y = [];
    for (var i = 0; i < x.length; i++) {
      var tough = toughness(k,[x[i]])[0];
      var net = netsection(s,[x[i]])[0];
      if (net < tough) {
        y.push(net);
      }
      else {
        y.push(tough);
      }
    }
    return y;
  }
  var trace1 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: '7178'
  };
  trace1.y = minval(43,74,trace1.x);
  var trace2 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: '7075'
  };
  trace2.y = minval(68,63,trace2.x);
  var trace3 = {
    x: makeArr(0,1,200),
    y: [],
    mode: 'lines',
    type: 'scatter',
    name: '2024'
  };
  trace3.y = minval(144,42,trace3.x);
  var data = [trace1, trace2, trace3];
  layout = {
    xaxis: {
      title: 'a/W'
    },
    yaxis: {
      title: 'residual strength',
      range: [0,80]
    }
  };
  Plotly.newPlot('comparison', data, layout);
	}"
}
-->
:::

## using MIL-handbook

-   Uses a different grain nomenclature

| \\(K_c\\) | \\(\sigma_{YS}\\) |
|:-----------------:|:---------------:|
|        L-T        |           L     |
|        T-L        |          L-T    |

-   A-Basis vs. B-Basis values are reported (A = 99% of population will meet/exceed value, B = 90% of population)
-   S-Basis - no statistical information available, standard value to be used


## using MIL-handbook

-   \\(F_{tu}\\) - ultimate tensile strength
-   \\(F_{ty}\\) - tensile yield strength
-   \\(F_{cy}\\) - compressive yield strength
-   \\(F_{su}\\) - ultimate shear strength
-   \\(F_{bru}\\) - ultimate bearing strength
-   \\(F_{bry}\\) - bearing yield strength
-   *E* - tensile Young's Modulus
-   \\(E_c\\) - compressive Young's Modulus
-   *G* - shear modulus
-   \\(\mu\\) - Poisson's ratio


## data

-   Fracture data is on pp. 111-121
-   Tensile data is on pp. 138-143
-   \\(K_c\\) charts are also available in interactive versions [here](http://ndaman.github.io/damagetolerance/examples/Fracture%20Toughness%20Figures.html)



# fedderson approach


## Fedderson approach

-   Unfortunately, the method we described above does not quite match experimental results
-   Fedderson proposed an alternative, where we connect the net-section yield and brittle fracture curves with a tangent line
-   This approach agrees very well with experimental data
-   Note: We could do something similar when the crack is very long, but we are generally less concerned with this region (failure will have already occurred)


## Fedderson example

worked example [here](https://colab.research.google.com/drive/1qPFJt95_5DGR7wDuKX0ntGOoPwQXcGFU?usp=sharing)


# proof testing


## proof testing

-   Proof testing is a way to use the concept of residual strength to check the size of a defect from manufacturing
-   Due to the fatigue life of a certain panel, and/or an inspection cycle that we have prescribed for that part, we determine an "acceptable" initial flaw size, \\(a_0\\)


## proof testing

-   We then determine a load which would cause failure at this crack length
-   This is the "proof load"
-   If the part does not fail in the proof test, we can assume that the largest flaw in the material is \\(a_0\\)


## example

-   Suppose we are concerned about edge cracks in a panel with \\(\sigma_{YS}=65\\) ksi, \\(W=5"\\)
-   We have determined that the largest allowable crack is 0.4"
-   The fracture toughness of this panel is \\(K_c = 140 \text{ ksi} \sqrt{\text{in.}}\\)


## example
-   We can find the proof load

\\[\begin{aligned}
  \sigma_c &= \frac{K_c}{\sqrt{\pi a_0} \beta}\\
  &= \frac{140}{\sqrt{\pi 0.4} (1.161)}\\
  &= 107.6
\end{aligned}\\]

-   So the proof load would need to induce a gross section stress of 107.6 ksi.


# residual strength review


## residual strength review

-   Group 1 - Sketch a residual strength curve for a single material (include fracture and net-section yield)
-   Group 2 - Sketch and describe the difference in residual strength between stiff/brittle materials and ductile/tough materials
-   Group 3 - Find the proof load needed to ensure no center-cracks less than 0.01" are present in a material with \\(K_C = 120 \text{ ksi}\sqrt{\text{in.}}\\)


## residual strength review
-   Group 4 - Sketch the Fedderson approach to residual strength. How is this different from the traditional approach? Why is it beneficial?

